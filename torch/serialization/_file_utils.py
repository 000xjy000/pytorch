import io
import shutil
import sys
import tempfile
import torch

from contextlib import contextmanager
from torch._six import PY2

if not PY2:
    import pathlib


def is_zipfile(f):
    # This is a stricter implementation than zipfile.is_zipfile().
    # zipfile.is_zipfile() is True if the magic number appears anywhere in the
    # binary. Since we expect the files here to be generated by torch.save or
    # torch.jit.save, it's safe to only check the start bytes and avoid
    # collisions. See bugs.python.org/issue28494.

    # Read the first 4 bytes of the file
    read_bytes = []
    start = f.tell()

    f.seek(0)
    byte = f.read(1)
    while byte != "":
        read_bytes.append(byte)
        if len(read_bytes) == 4:
            break
        byte = f.read(1)
    f.seek(start)

    # zip magic numbers
    magic_numbers = [
        ['P', 'K', '\x03', '\x04'],
        ['P', 'K', '\x05', '\x06'],
        ['P', 'K', '\x07', '\x08'],
    ]
    for magic_number in magic_numbers:
        match = True
        for magic_byte, read_byte in zip(magic_number, read_bytes):
            if ord(magic_byte) != ord(read_byte):
                match = False
                break
        if match:
            return True
    return False


def is_path(name_or_buffer):
    return isinstance(name_or_buffer, str) or \
        (sys.version_info[0] == 2 and isinstance(name_or_buffer, unicode)) or \
        (sys.version_info[0] == 3 and isinstance(name_or_buffer, pathlib.Path))


class opener(object):
    def __init__(self, file_like):
        self.file_like = file_like

    def __enter__(self):
        return self.file_like

    def __exit__(self, *args):
        pass


class open_file(opener):
    def __init__(self, name, mode):
        super(open_file, self).__init__(open(name, mode))

    def __exit__(self, *args):
        self.file_like.close()


class open_buffer_reader(opener):
    def __init__(self, buffer):
        super(open_buffer_reader, self).__init__(buffer)
        check_seekable(buffer)


class open_buffer_writer(opener):
    def __exit__(self, *args):
        self.file_like.flush()


def open_file_like(name_or_buffer, mode):
    if is_path(name_or_buffer):
        return open_file(name_or_buffer, mode)
    else:
        if 'w' in mode:
            return open_buffer_writer(name_or_buffer)
        elif 'r' in mode:
            return open_buffer_reader(name_or_buffer)
        else:
            raise RuntimeError("Expected 'r' or 'w' in mode but got {}".format(mode))


class open_zipfile_reader(opener):
    def __init__(self, name_or_buffer):
        super(open_zipfile_reader, self).__init__(torch._C.PyTorchFileReader(name_or_buffer))


class open_zipfile_writer_file(opener):
    def __init__(self, name):
        super(open_zipfile_writer_file, self).__init__(torch._C.PyTorchFileWriter(name))

    def __exit__(self, *args):
        self.file_like.write_end_of_file()


class open_zipfile_writer_buffer(opener):
    def __init__(self, buffer):
        self.buffer = buffer
        super(open_zipfile_writer_buffer, self).__init__(torch._C.PyTorchFileWriter(buffer))

    def __exit__(self, *args):
        self.file_like.write_end_of_file()
        self.buffer.flush()


def open_zipfile_writer(name_or_buffer):
    if is_path(name_or_buffer):
        container = open_zipfile_writer_file
    else:
        container = open_zipfile_writer_buffer
    return container(name_or_buffer)


def is_compressed_file(f):
    compress_modules = ['gzip']
    try:
        return f.__module__ in compress_modules
    except AttributeError:
        return False


def should_read_directly(f):
    """
    Checks if f is a file that should be read directly. It should be read
    directly if it is backed by a real file (has a fileno) and is not a
    a compressed file (e.g. gzip)
    """
    if is_compressed_file(f):
        return False
    try:
        return f.fileno() >= 0
    except io.UnsupportedOperation:
        return False
    except AttributeError:
        return False


def check_seekable(f):
    def raise_err_msg(patterns, e):
        for p in patterns:
            if p in str(e):
                msg = (str(e) + ". You can only torch.load from a file that is seekable." +
                                " Please pre-load the data into a buffer like io.BytesIO and" +
                                " try to load from it instead.")
                raise type(e)(msg)
        raise e

    try:
        f.seek(f.tell())
        return True
    except (io.UnsupportedOperation, AttributeError) as e:
        raise_err_msg(["seek", "tell"], e)


def maybe_decode_ascii(bytes_str):
    # When using encoding='bytes' in Py3, some **internal** keys stored as
    # strings in Py2 are loaded as bytes. This function decodes them with
    # ascii encoding, one that Py3 uses by default.
    #
    # NOTE: This should only be used on internal keys (e.g., `typename` and
    #       `location` in `persistent_load` below!
    if isinstance(bytes_str, bytes):
        return bytes_str.decode('ascii')
    return bytes_str


@contextmanager
def mkdtemp():
    path = tempfile.mkdtemp()
    yield path
    shutil.rmtree(path)
